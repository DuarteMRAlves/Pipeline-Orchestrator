/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.7/userguide/building_java_projects.html
 */

plugins {
    // Apply the java plugin to add support for Java
    id "java"
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'

    id "com.google.protobuf" version "0.8.12"

    id "idea"
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

def grpcVersion = "1.32.2"
def protobufVersion = "3.12.0"
def jacksonVersion = "2.12.0"
def log4jVersion = "2.12.1"

repositories {
    // Use JCenter for resolving dependencies.
    jcenter()
    mavenCentral()
}

dependencies {

    // This dependency is used by the application.
    implementation 'com.google.guava:guava:30.0-jre'

    // Grpc
    implementation "io.grpc:grpc-netty:${grpcVersion}"
    implementation "io.grpc:grpc-protobuf:${grpcVersion}"
    implementation "io.grpc:grpc-stub:${grpcVersion}"

    // Protobuf
    implementation group: "com.google.protobuf", name: "protobuf-java", version: "${protobufVersion}"
    implementation group: "com.google.protobuf", name: "protobuf-java-util", version: "${protobufVersion}"

    // For grpc reflection
    implementation "io.grpc:grpc-services:${grpcVersion}"
    implementation "com.google.api.grpc:proto-google-common-protos:1.16.0"

    // Reflection Utils
    implementation group: "org.reflections", name: "reflections", version : "0.9.12"

    if (JavaVersion.current().isJava9Compatible()) {
        // Workaround for @javax.annotation.Generated
        // see: https://github.com/grpc/grpc-java/issues/3633
        implementation "javax.annotation:javax.annotation-api:1.3.1"
    }

    // For parsing configuration
    implementation group: "com.fasterxml.jackson.dataformat", name: "jackson-dataformat-yaml", version: "${jacksonVersion}"

    // For logging
    implementation group: "org.apache.logging.log4j", name: "log4j-api", version: "${log4jVersion}"
    implementation group: "org.apache.logging.log4j", name: "log4j-core", version: "${log4jVersion}"

    testImplementation "io.grpc:grpc-testing:${grpcVersion}"

    // Use JUnit test framework.
    testImplementation 'junit:junit:4.13'
}

// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.
sourceSets {
    main {
        java {
            srcDirs "build/generated/source/proto/main/grpc"
            srcDirs "build/generated/source/proto/main/java"
        }
    }
    integration {
        proto {
            srcDir 'src/integration/proto'
        }
        java {
            srcDir 'src/integration/java'
        }
        resources {
            srcDir 'src/integration/resources'
        }
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

idea {
    module {
        testSourceDirs += project.sourceSets.integration.java.srcDirs
        testSourceDirs += project.sourceSets.integration.resources.srcDirs
    }
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.12.2"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
        }
    }
    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
    }
}

configurations {
    integrationImplementation.extendsFrom testImplementation
    integrationRuntimeOnly.extendsFrom testRuntimeOnly
}

task integrationTest(type: Test) {
    description = 'Run integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.integration.output.classesDirs
    classpath = sourceSets.integration.runtimeClasspath
    shouldRunAfter test
}

check.dependsOn integrationTest

processResources {
    dependsOn 'extractProto'
}

processTestResources {
    dependsOn 'extractTestProto'
}

processIntegrationResources {
    dependsOn 'extractIntegrationProto'
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

task buildDependencies(type: Copy) {
    from configurations.runtimeClasspath
    into 'build/libs'
}

abstract class DockerTask extends Exec {

    private String tag = 'latest'

    DockerTask() {
        commandLine 'docker', 'build', '-t', 'sipgisr/grpc-orchestrator:' + tag, '.'
    }

    @Option(
            option='tag',
            description='Configures the image tag for the docker build')
    void setTag(String tag) {
        this.tag = tag
        commandLine 'docker', 'build', '-t', 'sipgisr/grpc-orchestrator:' + tag, '.'
    }
}

task buildDocker(type: DockerTask)

buildDocker.dependsOn 'build', 'buildDependencies'

jar {
    manifest {
        attributes(
                'Main-Class':'pipeline.orchestrator.App'
        )
    }
}

test {

    // show standard out and standard error of the test JVM(s) on the console
    // testLogging.showStandardStreams = true

    afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
            def output = "Unit Tests Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            def startItem = '|  ', endItem = '  |'
            def repeatLength = startItem.length() + output.length() + endItem.length()
            println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
        }
    }
}

integrationTest {

    // show standard out and standard error of the test JVM(s) on the console
    // testLogging.showStandardStreams = true

    afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
            def output = "Integration Tests Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            def startItem = '|  ', endItem = '  |'
            def repeatLength = startItem.length() + output.length() + endItem.length()
            println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
        }
    }
}

run {
    systemProperties System.properties
}

application {
    // Define the main class for the application.
    mainClass = 'pipeline.orchestrator.App'
}
