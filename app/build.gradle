/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.7/userguide/building_java_projects.html
 */

plugins {
    // Apply the java plugin to add support for Java
    id "java"
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'

    id "com.google.protobuf" version "0.8.12"

    id "idea"
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

def grpcVersion = "1.32.2"
def log4jVersion = "2.12.1"
repositories {
    // Use JCenter for resolving dependencies.
    jcenter()
    mavenLocal {
        content {
            includeGroup "pipeline.core"
        }
    }
    mavenCentral()
}

dependencies {
    // PipelineCore
    implementation "pipeline.core:Pipeline-Core:0.0.2-SNAPSHOT"

    // This dependency is used by the application.
    implementation 'com.google.guava:guava:29.0-jre'

    // Grpc
    implementation "io.grpc:grpc-netty:${grpcVersion}"
    implementation "io.grpc:grpc-protobuf:${grpcVersion}"
    implementation "io.grpc:grpc-stub:${grpcVersion}"
    // For grpc reflection
    implementation "io.grpc:grpc-services:${grpcVersion}"
    implementation "com.google.api.grpc:proto-google-common-protos:1.16.0"

    if (JavaVersion.current().isJava9Compatible()) {
        // Workaround for @javax.annotation.Generated
        // see: https://github.com/grpc/grpc-java/issues/3633
        implementation "javax.annotation:javax.annotation-api:1.3.1"
    }

    // For logging
    implementation group: "org.apache.logging.log4j", name: "log4j-api", version: "${log4jVersion}"
    implementation group: "org.apache.logging.log4j", name: "log4j-core", version: "${log4jVersion}"

    testImplementation "io.grpc:grpc-testing:${grpcVersion}"

    // Use JUnit test framework.
    testImplementation 'junit:junit:4.13'
}

// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.
sourceSets {
    main {
        java {
            srcDirs "build/generated/source/proto/main/grpc"
            srcDirs "build/generated/source/proto/main/java"
        }
    }
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.12.2"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
        }
    }
    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
    }
}

task buildDependencies(type: Copy) {
    from configurations.runtimeClasspath
    into 'build/libs'
}

abstract class DockerTask extends Exec {

    private String tag = 'latest'

    DockerTask() {
        commandLine 'docker', 'build', '-t', 'orchestrator:' + tag, '.'
    }

    @Option(
            option='tag',
            description='Configures the image tag for the docker build')
    void setTag(String tag) {
        this.tag = tag
        commandLine 'docker', 'build', '-t', 'orchestrator:' + tag, '.'
    }
}

task buildDocker(type: DockerTask)

buildDocker.dependsOn 'build', 'buildDependencies'

jar {
    manifest {
        attributes(
                'Main-Class':'pipeline.orchestrator.App'
        )
    }
}

test {

    // show standard out and standard error of the test JVM(s) on the console
    // testLogging.showStandardStreams = true

    // listen to events in the test execution lifecycle
    beforeTest { descriptor ->
        logger.lifecycle("Running test: " + descriptor)
    }

    afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
            def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            def startItem = '|  ', endItem = '  |'
            def repeatLength = startItem.length() + output.length() + endItem.length()
            println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
        }
    }
}

run {
    systemProperties System.properties
}

application {
    // Define the main class for the application.
    mainClass = 'pipeline.orchestrator.App'
}
